<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
    <head><link rel="stylesheet" type="text/css" href="description/Combined.css,0:HeaderFooterSprite,0:Header.NonMtps,1:LinkList;/Areas/Centers/Themes/StandardDevCenter/Content:0,/Areas/Epx/Themes/Base/Content:1&amp;amp;hashKey=C9973DA951AE6202C9B348379A1BE49D" xmlns="http://www.w3.org/1999/xhtml" />
<link type="text/css" rel="stylesheet" xmlns="http://www.w3.org/1999/xhtml" />
<link rel="stylesheet" type="text/css" href="description/67b74b86-a273-4ad7-9ed5-0f97276412eaCombined.css,0:HeaderFooterSprite,0:Footer.NonMtps,1:LinkList;/Areas/Centers/Themes/StandardDevCenter/Content:0,/Areas/Epx/Themes/Base/Content:1&amp;amp;hashKey=F576C687BC536B84D6E5B3246EE39B49" xmlns="http://www.w3.org/1999/xhtml" />
<link type="text/css" rel="stylesheet" xmlns="http://www.w3.org/1999/xhtml" />

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Retrieving Volume GUID for a cluster volume (CppClusterDiskDetails)</title>
        <link href="description/Galleries.css" type="text/css" rel="Stylesheet" /><link href="description/Layout.css" type="text/css" rel="Stylesheet" /><link href="description/Brand.css" type="text/css" rel="Stylesheet" />
        <link href="description/iframedescription.css" rel="Stylesheet" type="text/css" />
        <script src="description/offline.js" type="text/javascript"></script>
        <style type="text/css">
            #projectInfo {
                overflow: auto;
            }
            #longDesc {
                clear:both;
                margin: 25px 0 10px 0;
            }

            #SampleIndexList{
                margin-left: 15px;
            }
        </style>
    </head>
<body>
    <div id="offlineDescription">
        <h1>Retrieving Volume GUID for a cluster volume (CppClusterDiskDetails)</h1>
        <br/>
        <div id="projectInfo">
            <div class="section">
                    <div class="itemBarLong tagsContainer">
                        <label for="Technologies">Technologies</label>
                        <div id="Technologies">
                            Windows SDK
                        </div>
                    </div>
                    <div class="itemBarLong tagsContainer">
                        <label for="Topics">Topics</label>
                        <div id="Topics">
                            Cluster API
                        </div>
                    </div>
                <div class="itemBarLong">
                    <label for="Platforms">Platforms</label>
                    <div id="Platforms">
                        Desktop
                    </div>
                </div>
                <div class="itemBarLong">
                    <label for="Requirements">Requirements</label>
                    <div id="Requirements">
                        
                    </div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Primary language</label>
                    <div id="LastUpdated">en-US</div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Updated</label>
                    <div id="LastUpdated">6/11/2012</div>
                </div>
                <div class="itemBarLong">
                    <label for="License">License</label>
                    <div id="License">
                        <a href="license.rtf">MS-LPL</a></div>
                </div>
                <div class="itemBar">
                    <div class="viewonlinecont">
                        <a data-link="online" href="http://code.msdn.microsoft.com/CppClusterDiskDetails-ef261cc2">View this sample online</a>
                    </div>
                </div>
            </div>
        </div>
        
                   
<script type="text/javascript">
    function initializePage() {
        var otherTabClass = 'otherTab';
        var hiddenPreClass = 'hidden';

        var htmlDecode = function(encodedData) {
            var decodedData = "";
            if (encodedData) {
                var div = document.createElement('div');
                div.innerHTML = encodedData;
                decodedData = div.firstChild.nodeValue.replace( /\\r\\n/ig , '\r\n');
            }
            return decodedData;
        };
                
        Galleries.iterateElem(Galleries.findElem(null, 'div', 'scriptcode'), function (index, scriptBlock) {
            var titleElem = Galleries.findElem(scriptBlock, 'div', 'title')[0];
            var labelElems = Galleries.findElem(titleElem, 'span');
            if (labelElems.length == 0) {
                labelElems = titleElem;
            }
            var languageSpans = Galleries.findElem(scriptBlock, 'span', 'hidden');
            var pres = Galleries.findElem(scriptBlock, 'pre');
            if (languageSpans.length > 0 && pres.length > 1) {
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    var languageSpan = languageSpans[index];
                            
                    elem.code = codePre.innerHTML.replace( /(\r(\n)?)|((\r)?\n)/ig , '\\r\\n');
                            
                    codePre.className = codePre.className.replace(hiddenPreClass, '');
                            
                    languageSpan.parentNode.removeChild(languageSpan);
                });

                pres = Galleries.findElem(scriptBlock, 'pre');
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    if (index == 0) {
                        scriptBlock.activeTab = 0;
                    }
                    else {
                        labelSpan.className += otherTabClass;
                        codePre.className += hiddenPreClass;
                    }
                    Galleries.attachEventHandler(labelSpan, 'click', function(e) {
                        var activeTab = scriptBlock.activeTab;
                        labelElems[activeTab].className += otherTabClass;
                        pres[activeTab].className += hiddenPreClass;

                        codePre.className = codePre.className.replace(hiddenPreClass, '');
                        labelSpan.className = labelSpan.className.replace(otherTabClass, '');
                        scriptBlock.activeTab = index;
                    });
                });

                var preview = Galleries.findElem(scriptBlock, 'div', 'preview');
                if (preview.length == 0) {
                    preview.push(pres[pres.length - 1]);
                }
                Galleries.iterateElem(preview, function(index, elem) {
                    elem.parentNode.removeChild(elem);
                });

                if (window.clipboardData && clipboardData.setData) {
                    var copyLink = document.createElement('a');
                    copyLink.href = 'javascript:void(0);';
                    copyLink.className = 'copyCode';
                    copyLink.innerHTML = 'Copy code';
                    Galleries.attachEventHandler(copyLink, 'click', function (e) {
                        clipboardData.setData("Text", htmlDecode(labelElems[scriptBlock.activeTab].code));
                        return false;
                    });
                    scriptBlock.insertBefore(copyLink, scriptBlock.childNodes[0]);
                }
            }
        });
    }

    Galleries.onWindowLoad(function(){
        initializePage();
    });

</script>
<div id="longDesc">
    
<h1><span>R</span>etrieve the Volume GUID of the Cluster Disks (<span class="SpellE">CppClusterDiskDetails</span>)</h1>
<h2>Introduction</h2>
<p class="MsoNormal">This sample demonstrates how to retrieve the Volume GUID of the Cluster Disks.</p>
<h2>Running the Sample</h2>
<p class="MsoNormal">To test the sample, compile the program using Visual Studio 2010 and run on any of Windows 2008/Windows2008 R2 cluster nodes with/without cluster name as a command line parameter. It will then output all the cluster disks along with their
 Volume GUID.</p>
<h2>Using the Code</h2>
<p class="MsoNormal">You can use this project to programmatically retrieve the Volume GUID for the cluster disks, which can then be used with storage applications that requires Volume GUID as input for its operation.</p>
<p class="MsoNormal">The following code snippet is the key point of this sample. It checks if the resource is a valid cluster disk resource and returns its GUID and Path via out parameters.</p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C&#43;&#43;</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">cplusplus</span>
<pre class="hidden">/// &lt;summary&gt;
/// Checks if the resource is a valid cluster disk resource and returns its GUID and Path via out parameters. 
/// &lt;/summary&gt;
/// &lt;param name=&quot;hResource&quot;&gt;Handle for a cluster resource&lt;/param&gt;
/// &lt;returns&gt;TRUE if the GUID and Path is retrieved successfully else returns FALSE&lt;/returns&gt;
BOOL CheckDiskResourceAndGetDetails( HRESOURCE hResource, LPWSTR szGUID, LPWSTR szPath)
{
        BOOL bIsDisk = FALSE;
        CLUSPROP_VALUE *cv = NULL;
        BYTE* lpbBuffer = NULL;
        DWORD dwRetVal;
        DWORD dwBytes = 0;


        dwRetVal = ClusterResourceControl(
                                            hResource,
                                            NULL,
                                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO_EX,
                                            NULL,
                                            0,
                                            lpbBuffer,
                                            0,
                                            &amp;dwBytes 
                                            );


        if( ERROR_MORE_DATA == dwRetVal || ERROR_SUCCESS == dwRetVal )
        {
            if(lpbBuffer)
            delete [] lpbBuffer;


            lpbBuffer = new BYTE[dwBytes];


            if( NULL == lpbBuffer )
            {
                wprintf( L&quot;Error: could not allocate memory.\n&quot; );
                return FALSE;
            }


            dwRetVal = ClusterResourceControl(
                                                hResource,
                                                NULL,
                                                CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO_EX,
                                                NULL,
                                                0,
                                                lpbBuffer,
                                                dwBytes,
                                                &amp;dwBytes 
                                                );


            if( ERROR_SUCCESS != dwRetVal &amp;&amp; ERROR_INVALID_FUNCTION != dwRetVal )
            {
                if( ERROR_MORE_DATA == dwRetVal )
                {
                wprintf( L&quot;Error: more data needed.\n&quot; );
                }
                else
                {
                wprintf( L&quot;ClusterResourceControl failed: %d\n&quot;, dwRetVal );
                }
            }
            else
            {
                cv = (CLUSPROP_VALUE *)lpbBuffer;


                while( (NULL != cv) &amp;&amp; (CLUSPROP_TYPE_PARTITION_INFO_EX != cv-&gt;Syntax.wType) )
                {
                    cv = (CLUSPROP_VALUE *) (((BYTE*)&amp;(cv-&gt;cbLength)) &#43; cv-&gt;cbLength 
                    &#43; sizeof(DWORD));


                    if(cv &gt;= (CLUSPROP_VALUE *) &amp;lpbBuffer[dwBytes])
                    {
                    cv = NULL;
                    }
                }


                if( NULL != cv )
                {
                    bIsDisk = TRUE; 
                    GUID guid = ((CLUSPROP_PARTITION_INFO_EX*)cv)-&gt;VolumeGuid;
                    ::StringFromGUID2( guid,szGUID,MAX_PATH);
                    wsprintf(szGUID,L&quot;%s&quot;,szGUID);
                    wsprintf(szPath,L&quot;%s&quot;,((CLUSPROP_PARTITION_INFO_EX*)cv)-&gt;szDeviceName);
                }
            } // else error_success


            delete [] lpbBuffer;
        }
        else if( ERROR_SUCCESS != dwRetVal &amp;&amp; ERROR_INVALID_FUNCTION != dwRetVal )
        {
            wprintf( L&quot;ClusterResourceControl failed: %d\n&quot;, dwRetVal );
        }


        return bIsDisk;
}

</pre>
<pre id="codePreview" class="cplusplus">/// &lt;summary&gt;
/// Checks if the resource is a valid cluster disk resource and returns its GUID and Path via out parameters. 
/// &lt;/summary&gt;
/// &lt;param name=&quot;hResource&quot;&gt;Handle for a cluster resource&lt;/param&gt;
/// &lt;returns&gt;TRUE if the GUID and Path is retrieved successfully else returns FALSE&lt;/returns&gt;
BOOL CheckDiskResourceAndGetDetails( HRESOURCE hResource, LPWSTR szGUID, LPWSTR szPath)
{
        BOOL bIsDisk = FALSE;
        CLUSPROP_VALUE *cv = NULL;
        BYTE* lpbBuffer = NULL;
        DWORD dwRetVal;
        DWORD dwBytes = 0;


        dwRetVal = ClusterResourceControl(
                                            hResource,
                                            NULL,
                                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO_EX,
                                            NULL,
                                            0,
                                            lpbBuffer,
                                            0,
                                            &amp;dwBytes 
                                            );


        if( ERROR_MORE_DATA == dwRetVal || ERROR_SUCCESS == dwRetVal )
        {
            if(lpbBuffer)
            delete [] lpbBuffer;


            lpbBuffer = new BYTE[dwBytes];


            if( NULL == lpbBuffer )
            {
                wprintf( L&quot;Error: could not allocate memory.\n&quot; );
                return FALSE;
            }


            dwRetVal = ClusterResourceControl(
                                                hResource,
                                                NULL,
                                                CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO_EX,
                                                NULL,
                                                0,
                                                lpbBuffer,
                                                dwBytes,
                                                &amp;dwBytes 
                                                );


            if( ERROR_SUCCESS != dwRetVal &amp;&amp; ERROR_INVALID_FUNCTION != dwRetVal )
            {
                if( ERROR_MORE_DATA == dwRetVal )
                {
                wprintf( L&quot;Error: more data needed.\n&quot; );
                }
                else
                {
                wprintf( L&quot;ClusterResourceControl failed: %d\n&quot;, dwRetVal );
                }
            }
            else
            {
                cv = (CLUSPROP_VALUE *)lpbBuffer;


                while( (NULL != cv) &amp;&amp; (CLUSPROP_TYPE_PARTITION_INFO_EX != cv-&gt;Syntax.wType) )
                {
                    cv = (CLUSPROP_VALUE *) (((BYTE*)&amp;(cv-&gt;cbLength)) &#43; cv-&gt;cbLength 
                    &#43; sizeof(DWORD));


                    if(cv &gt;= (CLUSPROP_VALUE *) &amp;lpbBuffer[dwBytes])
                    {
                    cv = NULL;
                    }
                }


                if( NULL != cv )
                {
                    bIsDisk = TRUE; 
                    GUID guid = ((CLUSPROP_PARTITION_INFO_EX*)cv)-&gt;VolumeGuid;
                    ::StringFromGUID2( guid,szGUID,MAX_PATH);
                    wsprintf(szGUID,L&quot;%s&quot;,szGUID);
                    wsprintf(szPath,L&quot;%s&quot;,((CLUSPROP_PARTITION_INFO_EX*)cv)-&gt;szDeviceName);
                }
            } // else error_success


            delete [] lpbBuffer;
        }
        else if( ERROR_SUCCESS != dwRetVal &amp;&amp; ERROR_INVALID_FUNCTION != dwRetVal )
        {
            wprintf( L&quot;ClusterResourceControl failed: %d\n&quot;, dwRetVal );
        }


        return bIsDisk;
}

</pre>
</div>
</div>
<div class="endscriptcode">&nbsp;</div>
<p class="MsoNormal">&nbsp;</p>
<h2>More Information</h2>
<p class="MsoNormal"><span>For more information on the control code CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO_EX click<br>
</span><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb309097.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/bb309097.aspx</a><span>
</span></p>
<p class="MsoNormal"><span>MSDN: <span class="SpellE">ClusterResourceControl</span> function<br>
</span><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa369016.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa369016.aspx</a><span>
</span></p>
<p class="MsoNormal"><span>MSDN: Resource Control Codes<br>
</span><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa372232.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa372232.aspx</a><span>
</span></p>
<p class="MsoNormal"><span>MSDN: CLUSPROP_VALUE structure<br>
<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa368393.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa368393.aspx</a>
</span></p>
<p class="MsoNormal"><span>MSDN: CLUSPROP_PARTITION_INFO_EX<br>
<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb309113.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/bb309113.aspx</a>
</span></p>
<p class="MsoNormal"><span>&nbsp;</span></p>
<hr>
<div><a href="http://go.microsoft.com/?linkid=9759640" style="margin-top:3px"><img src="description/95e3bc78-76ea-4f7c-8b0e-445ca740f249image.png" alt="">
</a></div>

</div>


    </div>
</body>
</html>
